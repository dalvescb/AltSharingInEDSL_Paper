% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
\usepackage{listings}
\usepackage{minted}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%
\begin{document}
\lstset{language=haskell}
%
\title{Alternative Methods for Implementing
    Explicit and Finding Implicit Sharing in embedded DSLs}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Curtis D'Alves \and
Christopher Anand \and
Lucas Dutton \and
Steven Gonder
}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{McMaster University, 1280 Main St W Hamilton, Canada}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
TODO The abstract should briefly summarize the contents of the paper in
150--250 words.

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%
\section{Introduction}

TODO describe sharing problem (mention observable sharing
\cite{gill:observablesharing} and implicit/explicit sharing
\cite{kiselyov:sharing} papers)

TODO describe finally tagless \cite{carette:finallytagless}

We present methods for implementing embedded DSLs with sharing that are both
safe and maintain all the benefits of being embedded in the Haskell ecosystem.
This means DSL functions are type-safe, do not require the use of unsafe
referencing (i.e., via unsafePerformIO) and can return Haskell's container
types (i.e., tuples, lists, etc) without breaking sharing.

\section{Detecting Sharing}

A naive DSL implementation of an expression in Haskell can be done via standard
Haskell data types, for example:

\begin{minted}{haskell}
data Exp
  = Add Exp Exp
  | Variable String
  | Constant Int

-- Example
v0 = Variable ``v0''
exp0 = Add v0 (Constant 0)
exp1 = Add exp0 exp0
\end{minted}

Note the DSL generates a tree, or to be more specific an Abstract Syntax Tree
(AST). Common features a DSL implementer might implement would include code
generation or pretty printing. Simple traversal of the AST for either of these
operations would result in duplication, for example in the above code snippet
the AST for {\bf exp0} will be traversed twice. For code generation in
particular this would be problematic, in order to circumvent this problem in
general we need to perform common subexpression elimination by converting the
AST into a directed acyclic graph. % #TODO cite literature

TODO describe DAG conversion by pointer comparison in the state monad

\subsection{Detecting Sharing In Finally Tagless DSLs}

Monads are useful, but don't make for a very user friendly DSL. It would be nice
to make use of monadic state when we need it (i.e., for converting to a DAG)
while hiding it behind a nice pure interface. The final tagless approach of
\cite{carette:finallytagless} is popular for accomplishing this. In this
approach, DSL expressions are built using typeclass methods that wrap the DSL in
a parameterized representation. For example, the previous data type based DSL
could be written in finally tagless as

\begin{minted}{haskell}
class Exp repr where
  add :: repr Int -> repr Int -> repr Int
  variable :: String -> repr Int
  constant :: Int -> repr Int
\end{minted}

We can then create different instances to implement different functionality.
For example, we can generate the AST from the previous DSL like so
\begin{minted}{haskell}
newtype ExpR a = ExpR { unExpR :: Exp }

instance Exp ExpR where
  constant = ExpR . Constant
  variable = ExpR . Variable
  add (ExpR x) (ExpR y) = ExpR (Add x y)
\end{minted}

Or we can implement pretty printing
\begin{minted}{haskell}
newtype Pretty a = Pretty { unPretty :: String }

instance Exp Pretty where
  add x y = Pretty $ "("++unPretty x++") + ("++unPretty y++")"
  variable x = Pretty x
  constant x = Pretty $ show x
\end{minted}

And use the same DSL code to run either implementation
\begin{minted}{haskell}
exp :: Exp repr => repr Int -> repr Int
exp v0 =
  let
    exp0 = add v0 (constant 0)
  in add exp0 exp0

expR = unExpR $ exp $ variable "v0"
expP = unPretty $ exp $ variable "v0"
\end{minted}

Finally tagless style provides extensible, user friendly DSLs. However there
are still some complications when using it to implement sharing.

\subsection{Implicit Sharing Via Hash-Consing}
TODO
cite Ershovâ€™s original description of hash-consing \cite{ershov1958:consing}
cite Type safe consing implementation (with performance benchmarks) \cite{filliatre:typesafeconsing}

In \cite{kiselyov:sharing}, a solution for detection implicit sharing in finally
tagless style is presented via the method of hash-consing. You can find a more
throrough explanation of the method there, but we'll give an overview here. This
method first involves defining a DAG type, for example
\begin{minted}{haskell}
type NodeID = Int
data Node = NAdd NodeID NodeID
          | NVariable String
          | NConstant Int


data BiMap a -- abstract
lookup_key :: Ord a => a -> BiMap a -> Maybe Int
lookup_val :: Int -> BiMap a -> a
insert :: Ord a => a -> BiMap a -> (Int,BiMap a)
empty :: BiMap a

newtype DAG = DAG (BiMap Node) deriving Show
\end{minted}

Note the purpose of the BiMap type is to be able to quickly insert and lookup
nodes by their NodeID (i.e., a bijection of Node's and their NodeID's), and is
most optimally implemented as a hash table with linear probing. The
representation for the finally tagless instance is then a wrapper around a State
monad that holds DAG in its state and returns the current (top) NodeID.

\begin{minted}{haskell}
newtype Graph a = Graph { unGraph :: State DAG NodeID }

instance Exp Graph where
  constant x = Graph (hashcons $ NConstant x)
  variable x = Graph (hashcons $ NVariable x)
  add e1 e2 = Graph (do
                     h1 <- unGraph e1
                     h2 <- unGraph e2
                     hashcons $ NAdd h1 h2)
\end{minted}

The trick to uncovering sharing in the implementation is implemented via the
{\bf hashcons} function, which inserts a new node into the current DAG, but not
before checking if it is already there.
\begin{minted}{haskell}
hashcons :: Node -> State DAG NodeID
hashcons e = do
  DAG m <- get
  case lookup_key e m of
    Nothing -> let (k,m') = insert e m
               in put (DAG m') >> return k
    Just k -> return k
\end{minted}

\subsection{Limitations of Hash-Consing}

When we wrap our State monad in finally tagless style, we lose some of Haskell's
built-in sharing capability. Consider the following code, note that the use of
local variables explicitely defines the computation $x + y$ to only be computed
once
\begin{minted}{haskell}
haskellSharing x y=
 let
   z = x + y
 in z + z
\end{minted}

Implicit sharing via hash-consing prevents duplication in the resulting DAG, but
unfortunately doesn't prevent redundant computation. Consider the following
equivalent attempt at using Haskell's built-in sharing in the finally tagless DSL
\begin{minted}{haskell}
redundant :: Exp Graph -> Exp Graph -> Exp Graph
redundant x y =
  let
    z = add x y
  in add z z
\end{minted}
Note {\bf z} is a wrapper around a State monad. Recall the implementation of
{\bf add} via hash consing
\begin{minted}{haskell}
add e1 e2 = Graph (do
                   h1 <- unGraph e1
                   h2 <- unGraph e2
                   hashcons $ NAdd h1 h2)
\end{minted}
In order to

TODO describe add-chains example

TODO translate to kiselyov's language
\begin{minted}{haskell}
addChains :: forall repr. CoreISA repr => (repr VR, repr VR, repr VR, repr VR) -> (repr VR, repr VR, repr VR, repr VR)
addChains =
      add2 . add1
    . add2 . add1
    . add2 . add1
    . add2 . add1
    . add2 . add1
\end{minted}

\subsection{Explicit Sharing and Limitations}
TODO

\section{Implicit Sharing Via ByteString ASTs}
TODO

\subsection{Memory Limitations}
TODO
\section{Explicit Sharing Of ByteString ASTs}
TODO

\subsubsection{Acknowledgements} Please place your acknowledgments at
the end of the paper, preceded by an unnumbered run-in heading (i.e.
3rd-level heading).

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
\bibliographystyle{splncs04}
\bibliography{references}

\end{document}

% LocalWords:  DSLs unsafePerformIO Haskell's AST typeclass tagless
% Local Variables:
% LaTeX-verbatim-environments-local: ("minted")
% eval: (setq-local LaTeX-indent-environment-list (cons '("minted" current-indentation) (default-value 'LaTeX-indent-environment-list)))
% End: